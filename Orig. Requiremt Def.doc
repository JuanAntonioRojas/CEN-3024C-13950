1. Introduction


The goal of requirements engineering is to understand what various stakeholders need from a system, and to document these needs in a way that they can be analyzed, communicated, and agreed upon.” (Ian Sommerville, Chapter 4, p. 83)
1.1. Purpose
This document aims at defining the software requirements for my inventory application. This requirements document will serve as a guide for clients, and a future development team, with the understanding that all aspects of the system are well-covered and agreed upon. My application integrates a friendly UI with a powerful Database for inventory, user and supplier management.
1.2. Scope
On this document I will cover the expected functional and non-functional requirements, including adding, updating or deleting items, users and/or suppliers.
My system follows a 3-tier architecture, dividing the application into the presentation layer, application logic layer, and data layer. Each tier is robust enough to handle peak usage and also allow for future growth.
I've broken down what the app needs to do (making it user friendly), how the data is set up, and the points we need to consider for security reasons. Later on, I will add a sales side with customers, invoices, ticket-items, etc., but for now, this document is basically my contract of what this app will deliver.

2. System Overview
"Always deliver more than expected." (Larry Page)
This software is simple and easy to use, for both managers and employees. It is connected to a database that allows for item searches for viewing, updating or deleting (manager only), with real-time inventory updates on every sale.
As I mentioned, I will soon convert this app to an API that will integrate with an eCommerce platform to allow the online user to place orders, check on his or her delivery, etc. The App will also integrate seamlessly with third-party services such as a payment gateway, shipping services, drop-shipping, and our suppliers.

2.1. Object Definition: What We're Tracking
My project is going to manage three main kinds of records: (A) Products (the inventory in the warehouse: stuff for sale), (B) Users (who can log in: Admins and Staff), and (C) Suppliers (who supplies the products).
A)  The Product Object (The Inventory)
I set up at least six fields with different data types to make a proper item record:



3. Functional Requirements: What does the App Do?
“Functional requirements define the interactions between the system and its users or other systems. They specify what the system should do and how it should respond to inputs, providing a detailed description of the system’s behavior.” (Ian Sommerville,  Ch. 4, p. 85)
The Admin (Manager) is in charge of ordering (creating) new items from suppliers, monitoring customer’s orders (reducing inventory) and handling returns/refunds (adding inventory). Through this app they are constantly updating the backend database (with the sku, name, price, description, quantity, etc.). The system will also “keep an eye out” so to speak on “low” stock levels (and prepare an order if necessary).
This is a table with the main things any user can actually do with the data. (Note: Only the manager (admin) is privileged to do the same crud operations not only on products but also in regards to suppliers and other users.)

3.1. CRUD Operations (The Basics):
Create (Add):	Put new stuff in the system.	Click the "Add" button, fill out the modal form, and hit "Save." If “Cancel” is clicked the in-memory record is cleared.
Read (Display):	See everything we have in stock.	The main screen loads an automatically refreshing, scrollable table showing all records.
Update:	Change the details (like name, price or quantity) of an item.	Select a row, click "View / Update," change the values in the form, and save.
Delete (Remove): Get rid of old or discontinued items.	Select a row and hit "Remove Selected," or type the SKU into the search box and click "Remove by ID."

3.2. Custom Actions (The Math)
What gets measured gets managed." (Peter Druker)
I designed two custom actions that give the manager extra business info:
    1. Inventory Value Calculation (Math Action): The app will figure out the total cash value of everything we have in stock. It runs a calculation on all products: Sum of (quantity x price). The result shows in a separate column.
    2. Purchase Order Alert (Custom Logic): This is a handy check. The system automatically scans the inventory and pops up a clear Alert Dialog listing any product where the quantity drops below a certain number. This basically tells the manager, "Time to order this stuff!"

3.3. User Roles and Access
“The goal of interactive design is to provide users with the necessary tools to accomplish their tasks in a way that feels natural and efficient." (Shneiderman & Plaisant)
I created two levels of access, which are controlled at login:
    • Admin: Gets full access (CRUD on Products, Users, and Suppliers). They're the only ones who have available the buttons for "View Users" and "View Suppliers". Once they click on each, a new table (scene) will replace the default Products Table, and it will have the same CRUD buttons on the left nav panel: add/update/delete users & suppliers.
    • Staff/General User: Product-only access (CRUD on Products). They cannot see or access the User or Supplier management modules.



4. Non-functional Requirements: Making it Run Well
“Non-functional requirements may be more critical than functional requirements. If these are not met, the system may be useless.” (Ian Sommerville, Chapter 4, p. 96)
These are the "under the hood" things that make my app reliable, especially if the client ever decided to offer this to a ton of employees (which they probably won't, but I gotta plan for it).

4.1. Security 
“Security is a process, not a product." (Bruce Schneier)
Sanitizing the inputs:
All user data will be sanitized (especially with regex) and validated before processing. 
Strong Password Hashing:
We're not storing plain passwords. They're going into the database as BCrypt hashes, with a 22 character Salt at a “Cost” of 12 (extremely safe). My system also tracks login attempts, and locks out users after 5 failures to stop hackers from guessing usernames and/or passwords. When we go eCommerce (SpringBoot), all data going into the DB will be hashed with BCrypt, so that even if a hacker can access the DB he wouldn’t know what’s in there. We’ll also implement a 2-Factor Authentication and a Capcha puzzle, against bots.

4.2. Reliability
"Availability and reliability are two of the most important characteristics of a system. They are the keys to delivering a system that meets user expectations and withstands real-world conditions." (Martin L. Abbott  & Michael T. Fisher)
Reliability is paramount to an Inventory Management System (IMS), as downtime or data corruption directly impacts staff productivity, order fulfillment, and financial records. My goal is to ensure the system is continuously available and resilient against both environmental failures and user error. 
4.2.1. Crash-Proof Validation:
The application will not crash due to user input. Input Validation is implemented across all data entry fields to prevent errors and protect data integrity.
    • Preventing User Errors: Fields include a promptText suggesting the correct data format and type. If a user enters invalid data (e.g., "twenty dollars" in the Price field) or attempts to enter a duplicate SKU, the app will catch the error and display a polite, informative alert, rather than failing abruptly.
    • Security: Enhanced Input Defense. Input fields are secured with Regular Expressions (regex) to perform basic client-side sanitization, to reject SQL keywords and protect the underlying DB. But since client-side validation can be easily bypassed, the code also has server-side neutralization to strip out malicious scripts (such as <script> tags, event handlers like onload, and JavaScript code) to prevent Cross-Site Scripting (XSS) attacks, thereby protecting the integrity of the data.
4.2.2. Failover:
In the event of critical failures (power outages, server hardware failure, network disconnection, etc.), an automatic failover mechanism will be engaged.
    • Local: For on-premises deployment, this involves Uninterruptible Power Supplies (UPS) and local load balancing.
    • Cloud: With cloud deployment, services like Kubernetes and automatic server replication ensure continuous online service without delay, eliminating downtime and preventing disruption to staff operations.
4.2.3. Uptime Commitment:
I commit to a system uptime of 99.9% (24/7), and I minimize downtime and ensure constant availability of the IMS for all staff and administrators, which is essential for business continuity, especially during periods like hurricanes or electric cutoffs.
4.2.4. Redundancy:
At this stage on my application there’s no need to maintain redundant servers for the logic and GUI. Just the right backups. However I can set up 2 database configurations, one local and one online (just in case). This practice is necessary to ensure the system remains operational even in the case of a single hardware component failure. Redundancy is a strategy against unpredictable environmental factors, such as in case of lightning.
4.2.5. Backup and Recovery:
A comprehensive Backup and Recovery plan is in place to safeguard the app and data:
    A) Backups: The client will oversee a daily database backup (through the implementation of a shell script that uses the native “mysqldump” utility).
    B) Disaster Recovery Plan: The following plan outlines the process and target time-frames for restoring the IMS and its data following a catastrophic event: 
    1. Immediate Stop: Instantly shut down the system to avoid extra damage.
    2. New Foundation: Immediately set up a new, clean database in a safe server.
    3. Restore Data: Take the last good daily backup (done every night) and pour all the saved product, user and supplier’s data, and order information into the new database.
    4. Launch Application: Point the inventory app to this new, clean DB. Since the passwords and settings are stored safely outside the app’s code, the system quickly reconnects.
    5. Operation Resumes: The staff can resume their work within the one-hour window, relying on data that is at most 24 hours old.
4.2.6. App Deployment:
The IMS deployment will follow a staged approach:
    • Initial Deployment: Everything will be deployed “on-prem” (in-house server) for initial testing and internal use.
    • Future Scaling: As the project grows and the number of concurrent sessions increases, I will acquire cloud space with a reliable host like Amazon AWS or Microsoft Azure. Scaling to the cloud is the best strategy to handle increased traffic and robustly avoid issues like Denial of Service attacks

4.3. Performance
"We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil." (Donald Knuth)
My primary goal for the Inventory Management System is to write code that is correct, readable, and maintainable. I don’t want to waste time optimizing code that rarely runs efficiently. The user experience is completely tied to the system’s performance, load time, concurrency during peak order processing, or the speed of data synchronization processes. Performance is critical.
4.3.1. Application Responsiveness (Page Load Time):
I designed the app to load the primary GUI frames (like the Product Table views) quickly.
The loading time might slightly increase due to peak concurrent demand (e.g., multiple staff members performing end-of-day processes). While currently served locally, upgrading to a major cloud provider (AWS, Google, or Azure) will maintain or improve these speeds, as the APIs and backend services handling stock queries and order updates will respond instantaneously. My goal is to ensure smooth user interaction, especially during a high volume of orders.
4.3.2. Concurrency:
This is essential for an effective IMS. Initially, I expect multiple simultaneous users (staff managing orders, updating stock, and running reports) without performance degradation. As the business scales, I will scale from on-prem to cloud to support thousands of simultaneous accesses (staff, admins, and potential e-commerce hooks) positively affecting the database performance.
    • Scaling Database Operations: Cloud database services like Amazon RDS or Google Cloud SQL provide the infrastructure for automatic scaling, replication, and failover. They ensure the database handles multiple concurrent queries for searches, filters, and stock updates.
    • Caching for Speed: Services like AWS ElasticCache or Azure Redis Cache will be implemented to access frequently requested data (e.g., top-selling products, user permissions), dramatically reducing load on the primary MySQL database and speeding up common operations.
4.3.3. Optimized Database Access:
All SQL queries that interact with the product and order data will utilize Prepared Statements. This is crucial for two reasons:
    • Security: It is the primary defense against SQL injection attacks, ensuring the integrity of the inventory data.
    • Performance: It significantly speeds up and makes database interaction more efficient, especially when loading large product lists or executing repetitive stock level update transactions. The database can reuse the execution plan for the query, leading to faster data retrieval and manipulation.

4.4. Scalability
"Architecture represents the significant design decisions that shape a system, where significant is measured by the cost of change." Grady Booch (UML creator)
If I made a bad choice in a small piece of code (like a single method), it'll be easy to fix. But if I made an initial bad choice in the architecture (like the DB technology or the APIs between major components), fixing it later will be extremely expensive and require long and hard modification time. In fact, this just happened when I decided to add Users and Suppliers to the Products DB and controllers logic, through Generics instead of repeating code. It took me days to fix: I had to drop a bunch of classes and write new ones. I felt as if I had started from scratch. May as well.

The level up to which my app can grow depends on whether I do either of these:
4.4.1. Vertical Scaling (Scaling Up)
    • Adding more hardware: Upgrading the server with a better CPU (cores), and more RAM.
    • Writing more efficient software: Better database normalization for faster queries. Optimizing the application logic, to make it more efficient in resource utilization.
    • Improve storage speed: Investing in more and faster storage solutions like RAID arrays, SSDs, or NVMe drives for better I/O performance.
4.4.2. Horizontal Scaling (Scaling Out)
The application logic and the database interaction (e.g. the ModelUserDB class full of MySQL queries) need to be in separate classes. That way, if I need to switch from MySQL to something bigger, like Oracle, I’ll only change a couple of model files, not the whole app. For now, my approach is just Horizontal Scaling (adding more servers) to handle high transaction volumes
    • Adding more servers: Increasing the number of servers to distribute the load across multiple machines, basically creating a server cluster that works as a single system.
    • Load Balancing: Implementing load balancers to distribute requests evenly across multiple servers to prevent any single server from being overwhelmed.
    • Database Replication: Set up database replication to spread the queries across multiple servers, improving performance without burdening the main database server.
    • Using cached layers: Implementing caching solutions like Memcached or Redis to reduce database load by storing frequently accessed data in memory.

4.5. Maintainability
"Any fool can write code that a computer can understand. Good programmers write code that humans can understand." (Martin Fowler)
This App is built with the understanding that “all software” requires ongoing maintenance (bug fixes, dependency updates, feature additions). By prioritizing clarity, simplicity, and intention (writing code for the human developer first) I’ll sharply reduce the time and effort needed for all future maintenance tasks on this codebase. // Clear comments are the key!
4.5.1. Modular Design:
My application uses a modular design based on the Model-View-Controller (MVC) pattern. The use of the Ctrl~, Model~, and View~ as class prefixes enforces separation of concerns:
    • Decoupling: I can update the UI logic (e.g., changing a button color in ViewFrame or CSS) without touching the core data logic in ModelUserDB or ModelProd.
    • Impact Isolation: Changes within one component's logic are less likely to introduce bugs in an entirely different part of the system, maintaining overall stability.
4.5.2. Documentation:
This Requirements Document, along with supplementary guides, will be provided to all developers and system administrators. This documentation details the system’s architecture, the database schema, and troubleshooting procedures specific to this application's functionality. I’ll provide up-to-date documentation for new technical aspects.
4.5.3. Version Control
I made extensive use of Git for this project to track every change I made to the source code. This practice was essential for:
    • Rollbacks: Ability to easily revert to previous stable versions of the program.
    • Consistency: Keeping a single, consistent version of the code across all development and deployment environments.
    • Future Collaboration: Facilitating controlled, concurrent work with other future developers.
4.5.4. Automated Testing
As expanded upon in Chapter 8, we will implement Automated Testing (Junit) to ensure the high quality and stability of the system. I will perform:
    • Unit Tests: To verify that individual components and methods (like the calculation in the totalCol logic) function correctly in isolation.
    • Integration Tests: To ensure that components work together seamlessly (e.g., the ControlProd successfully communicating with ModelUserDB).
    • Acceptance Tests: To confirm that the entire system meets the specified user requirements and is free of bugs that would disrupt its functionality.
4.5.5. Support Plan
Following the deployment of this program, I will continuously monitor its performance. The maintenance plan includes providing timely software updates and security patches to keep the application secure and functional for all users.
4.5.6. Incident Management
In the event of any problem affecting the program (outages, security breaches, or critical failures), I have a defined Incident Management plan (addendum at the end). This plan ensures a timely response and effective resolution to minimize downtime and secure the system's integrity.
4.5.7. Audit Trail
The history of all code changes for this system, once delivered, will be preserved as an Audit Trail within the GitHub repository. This facilitates transparent system support, allowing developers to trace when and by whom a specific feature or fix was introduced.



5.  Technical Architecture and Data Design
"Building reliable, scalable, and maintainable data systems is a complex task, but by carefully designing the architecture and considering the trade-offs, we can build systems that meet the needs of modern applications." (Martin Kleppmann)
My goal is to ensure that this Inventory Management System is robust, secure, scalable, and reliable, able to support any current and future demands of managing product stock. This includes handling security, responsiveness to bigger screen sizes, and high transaction volumes. 

5.1. Architectural Design: The 3-Tier Model
“The three-tier architecture is a widely used pattern for designing enterprise applications. It separates the system into three layers: presentation, application, and data. This separation helps in organizing code and allows for more scalable and maintainable systems.” (Ian Sommerville, Chapter 4, p. 96)
This inventory system is highly interactive, with dynamic, intuitive interfaces and, most importantly, a strong API integration connecting several critical services such as the Database and the Front End.
By implementing a separation of concerns, I significantly increased scalability, security, and proficiency in core inventory operations, including data management, user, and supplier management. As we saw earlier, data security is a big concern, and as we will see later, so is efficient data storage.
5.1.1. Presentation Layer:
The front-end includes the JavaFX components responsible for interacting with the user, displaying data (like product lists and stock levels), and sending requests to the server. In the future I will use technologies like HTML, CSS, and JavaScript, along with the Spring Boot framework to render the views. While this is a standalone Apps initially, a future expansion to a mobile app will use React Native. All Operating System that have a Java Virtual Machine installed can run my code. Note: I’ve prefixed with “View~” all front end classes.
5.1.2. Application Layer:
The middle tier handles the business logic of inventory management. This includes validating and processing user input, performing critical business operations such as order fulfillment, stock level updates, product searches, and account management. For now I exclusively use JavaFX due to its robustness, user friendliness and suitability for enterprise-level Java applications. Note: I’ve prefixed with “Ctrl~” all these classes.
5.1.3. Database Layer:
Connected through the Application layer, this the back end 3rd level that handles all data-related operations: storing, retrieving, updating, and deleting data. This includes user/supplier profiles, the complete product catalog, detailed item description, and current stock quantities. I have utilized MySQL for all data queries and transactions. Note: I’ve prefixed with “Model~” all back end classes.

5.2. Database Requirements and Modeling 
"A well-designed database ensures data consistency, integrity, and can efficiently handle high volumes of transactions." (Elmasri & Navathe).
5.2.1. Data Models and Integrity:
My collection of data (related to Products, Orders/Stock Transactions, etc.) is organized through a formal Entity-Relationship Diagram (ERD). This ERD defines the tables in my “inventory” DB and how they relate to each other (e.g., one Product can have many Suppliers, and a Supplier can bring many Products). Each entity has a unique Primary Key (e.g., productID, orderID), and the Foreign Keys establish the relationships between the tables. To optimize search performance and reduce data redundancy, I have normalized (3NF) the schema, ensuring strong data integrity across the system.
5.2.2. Product Inventory Database:
The purpose of this database is to store the complete Product Catalog, including their metadata (e.g., name, SKU, category, supplier) and inventory data (e.g., current stock levels, warehouse location, price). In the future, this database will also contain links to the product images to be displayed on the “scene” as well as include tracking of all customer orders, and shipment status. 

5.3. Data Persistence and Security Configuration
"A deployment pipeline should be fully automated, including the configuration of every environment. Application configuration must be stored outside the deployable artifact." (Jez Humble)
All persistent data for Products, Users, and Suppliers is stored in a MySQL relational database. To establish the connection, the system utilizes a robust and secure configuration pattern: the database credentials (URL, username, and password) are deliberately not hard-coded within the application source files. Instead, they are loaded at runtime from a secure config.properties file using a dedicated DBConfig utility class. This separation:
    • Enhances Security: By keeping sensitive credentials out of the public codebase, out of DBConfig.
    • Ensures Application Reliability: The same shared Connection instance is then injected into all data model managers (ModelProdDB, ModelUserDB, ModelSuppDB, etc.) via their constructors, preventing resource leaks and redundant, inefficient database connections.

5.4. Data Operations and Management Philosophy
"If you can't describe what you are doing as a process, you don't know what you're doing." (W. Edwards Deming)
According to Deming, the best way to handle data is not by doing things randomly, or depending on the weather; it's by focusing on clear, repeatable steps, consistent rules, and quality checks.
Why does this Matter?
    • It’s a Process: To manage the data I follow a controlled and ongoing routine. This includes everything from moving data around (like getting new inventory into the system) to running backups, keeping it secure, and controlling who can access it.
    • It Ensures Reliability: When I document something, and the users follow my steps, we can test them. This guarantees that the data that my client relies on, is his or her most important asset, and always accurate and trustworthy.
    • It Requires Governance: Having a database isn't enough. The stakeholders must have a clear, documented system that spells out exactly how data is created, kept up-to-date, and eventually removed.
5.4.1. Data Storage Plan
This Inventory Management System (IMS) uses MySQL because it's strong and scalable enough to handle all our current data, including product inventory and orders. As a client’s business grows, I'll look into moving the DB to cloud solutions (like AWS, Google, or Azure) to manage much larger amounts of data and ensure the system is always available.
Retention Periods: For legal compliance we’re required to hold data, such as:
    • Customer Data: Retained for up to 7 years to comply with tax and accounting regulations.
    • Inventory Data (Historical): Retained indefinitely to track historical stock levels and trends.
5.4.2. Backup and Recovery Procedures
Given the high probability of power surges in the local area (Central Florida), I’ve implemented strict backup measures to prevent data loss:
    • Scheduled Backups: Regular backups are scheduled on a daily and weekly basis. I use the command-line utility “mysqldump” to create a logical backup (a file containing SQL statements). An Admin must run this command from the operating system. But it can also be scheduled to run at a specified time (e.g., every night at 2:00 AM) with a simple shell script (“~.sh” or “~.bat”) containing the “mysqldump” command. 
    • Secure Storage: Daily backups will be stored in a secure location at the store, while weekly backups will be stored at a different physical location or in secure cloud storage for disaster preparedness.
    • Testing: We will regularly test these backups and the consequent recovery procedures to ensure data can be restored accurately and promptly when needed.
5.4.3. Data Import and Export Procedures
The system supports flexible procedures for data exchange:
    • Data Import: For bulk uploads of inventory, the “Load” button accepts the most popular data format: Comma Separated Values (CSV). The “Logic” ensures data integrity by checking for duplicate records, invalid data formats, and missing required fields.
    • Data Export: Later on I will ad an export data (e.g.: inventory levels) capability using commonly used formats such as CSV, Excel, or JSON. This data will be securely transmitted to facilitate data analysis and protected from unauthorized viewers.
    • External Integration: Later on I will implement seamless data exchange with external systems, such as payment gateways, accounting software, and third-party vendors.
5.4.4. Data Synchronization (In-store vs. Online)
Synchronization ensures consistency across all retail channels.
    • Mechanisms: I will use the same underlying database to ensure real-time data synchronization between in-store systems (DB) and online ones. This ensures that inventory levels, pricing, and order statuses are instantly updated.
    • Conflict Resolution: I will develop methods to resolve data discrepancies (e.g., a customer being entered as "Tony Rojas" and "Antonio Rojas") and conflicts between in-store and online updates by setting priorities on the data source. Audit Trails will be maintained to track discrepancies and resolve synchronization issues by identifying the source of change.
    • Performance and Scalability: Synchronization processes are designed to scale up with the growth of data volume and transaction frequency. We will monitor the performance of these processes to ensure they do not negatively impact overall system performance or user experience.



6. UI Design: What it Looks Like
“The user interface design should be based on a clear understanding of the user’s tasks and the system’s operational context. Effective interface design can significantly improve user productivity and satisfaction.” (Ian Sommerville. Chapter 16, p. 448)
 "It’s not that users don’t read; they just don’t read. They scan. They glance. They pick out keywords." (Steve Krug)
This app is the primary way the staff interacts with the warehouse. My design prioritizes minimalist simplicity and encourages users to explore and make changes. Managers can alter accounts with  buttons for operational functionality to view/alter users and suppliers.
The application uses a clean, single-window design with a blue color scheme for a relaxing and professional look. The entire user experience is built around clear visual progression and role-based access control.
"The goal of interaction design is to create products that are useful and satisfying to the user." (Alan Cooper)

6.1. Application Flow and Layout
The app begins with the Login Screen, which acts as the initial authentication gate, that uses a background image taken from Road Runner cartoons to give the app a familiar brand identity.
I picked “ACME” because Wile Coyote can order literally “anything” from them, and their products are available at any time and anywhere. Whether they work for him or not, that’s another issue.
The login form itself is contained within a centralized, semi-transparent box, offering a Username (email with a promptText="WileCoyote@gmail.com") and a Password (prompting: “Abc@123!”).
Upon successful authentication, the system transitions to the main inventory interface:

6.2. Role-Based Visibility
“Design is not just what it looks like and feels like. Design is how it works.”  (Steve Jobs)
The Navigation Panel implements strict access control:
    • Staff only sees Product Mgmt buttons (Add, Remove, View/Update, Load & Refresh).
    • Admin sees all product buttons plus the "View Users" and "View Suppliers" buttons, granting them exclusive access to the system's management and configuration modules. In other words: Anybody can add/remove/update items but only admins can do so for other users and suppliers.

6.3. Interaction and Feedback
All Create, View/Update operations trigger new modal dialog windows (not simple scene swaps) that force the user to complete or cancel the action, ensuring commit data integrity before returning to the main table. The UI also provides consistent feedback through tooltips, success messages, and clear, non-crashing error dialogs for any validation failures.



7. User Stories: How does the App Get Used
"A user story is a promise for a conversation." (Mike Cohn)
The core purpose of a user story is not as a finalized technical specification, but as a starting point for discussion about one required feature or another. The following user stories are invitations to further discussion. For the Inventory Management System, this means:

7.1. The Story is the Starting Line:
A story like, "As a Store Manager, I click the 'Low Stock Check' button... so I know exactly what to put on the purchase order." This is not the complete implementation of the feature, but it's the invitation to talk to the store manager to clarify:
    • What exactly is considered "low stock" (a fixed number, or a dynamic number based on sales velocity)?
    • What specific supplier information needs to be visible on that alert?

7.2. The Value is in the Conversation:
The actual value comes from the detailed discussions among the developers, the product owner, and the user (e.g., the inventory clerk or administrator). This conversation will ensure that my IMS system will be built to meet their exact, real-world workflow needs.
These interactions for the key actions, show how a user actually performs a task.

7.3. User vs. Admin Permissions
The core difference lies in their scope of control. Staff User is a general operator, granted only the necessary Product Management permissions to perform their daily job. This adheres to the security principle of least privilege. In contrast, the Admin is a privileged supervisor, possessing full system control. This includes all product permissions plus the ability to manage other Users (e.g., creating accounts, resetting passwords, changing roles) and manage the system's Suppliers data (e.g., adding a new vendor or updating contact information), making the Admin the only role that affects core application configuration and personnel access.



8. UML Use Case Diagrams
"Poor requirements are a major reason why software projects fail." (Ian Sommerville, Chp. 4)
With Use Case Diagrams we can model the functional requirements of a system by representing what the system does and its interactions with stakeholders, such as when an Actor originates high-level functions. The system performs these tasks without showing how those actions are carried out. Sommerville justifies the existence of a Use Case Diagram because:
Use Case Diagrams serve as Requirements: These diagrams are the first high-level model used to capture the functional requirements of the system. They get explicit requirements (before moving to design) and define the external limits and internal goals of the system.
Prevent Failure: These diagrams help prevent "poor requirements" from creeping in, that Sommerville warns about, which can lead to failure. They clarify the Actors and their intended goals at the earliest stage and ensure that the rest of the development process is building the correct system.

 8.1. Add New Record (Create)
The diagram shows the Actor initiating the action, the user inputting data, the system validating the input, and finally calling the DB to save the new record and updating the display. 

8.2. Remove Selected Product (Delete)
The diagram should show the Actor selecting a row, clicking the "Remove" button, the system displaying a confirmation box, and then executing the delete operation in the DB if confirmed.

8.3. Update A Record (Update)
The diagram shows the Actor selecting a record, clicking "View / Update," the system pre-filling the dialog, the user modifies the fields, and the system saves the updated data back to the DB.

8.4. UML Use Case: Low Stock Check (Custom Action)
This oneshows the Actor clicking the “Low Inventory” button, the system querying the full product list, and  displaying the "Purchase Order" popup to the user.



